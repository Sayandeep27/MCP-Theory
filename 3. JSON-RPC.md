# JSON-RPC in MCP â€“ Complete Beginner-Friendly Guide

---

# ğŸ“Œ What is JSON-RPC?

**JSON-RPC (JavaScript Object Notation â€“ Remote Procedure Call)** is a lightweight communication protocol that allows one system to call functions or methods on another system using JSON format.

In simple words:

> JSON-RPC is a structured way for two systems to talk to each other using JSON messages.

It is commonly used in distributed systems, APIs, blockchain networks, and modern AI communication frameworks like MCP.

---

# ğŸ§  Breaking the Term

| Term | Meaning                                                               |
| ---- | --------------------------------------------------------------------- |
| JSON | A lightweight data format used to structure data (key-value format)   |
| RPC  | Remote Procedure Call â€“ calling a function on another system remotely |

So,

JSON-RPC means:

> Calling a function on another machine using JSON-formatted messages.

---

# ğŸ— Basic Structure of JSON-RPC

A JSON-RPC request looks like this:

```json
{
  "jsonrpc": "2.0",
  "method": "getUser",
  "params": {
    "user_id": 101
  },
  "id": 1
}
```

### Explanation:

* `jsonrpc`: Protocol version
* `method`: Function to execute
* `params`: Input parameters
* `id`: Unique request identifier

---

# ğŸ“¥ JSON-RPC Response Example

```json
{
  "jsonrpc": "2.0",
  "result": {
    "name": "Alice",
    "age": 25
  },
  "id": 1
}
```

If an error occurs:

```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32601,
    "message": "Method not found"
  },
  "id": 1
}
```

---

# ğŸš€ Why JSON-RPC Is Used in MCP

JSON-RPC is used in MCP because it provides:

* Standardized communication format
* Lightweight message structure
* Easy parsing
* Clear request-response pairing using IDs
* Language-agnostic communication
* Simple function-calling abstraction

MCP requires a consistent way for:

* Clients to request tool execution/ db fetching
* Servers to execute tools/ db fetching
* Servers to return structured responses

JSON-RPC perfectly fits this requirement.

---

# ğŸ”„ Complete Flow: User â†’ Client â†’ Server â†’ Tools â†’ Server â†’ Cleint â†’ User

Now letâ€™s explain the full flow step-by-step in simple language.

---

# ğŸ§© Step 1 â€“ User Gives Question

User types inside an MCP Host application:

> "Create a GitHub issue and send a Slack notification."

The question is natural language.

At this stage:

* It is plain text
* Not structured
* Not protocol formatted

---

# ğŸ§  Step 2 â€“ LLM Inside Client Understands the Request

Inside the MCP Client:

* The LLM interprets user intent
* It determines which tools are required

The LLM decides:

* Tool 1: Create GitHub issue
* Tool 2: Send Slack message

---

# ğŸ“¦ Step 3 â€“ Client Converts Request into JSON-RPC Format

The MCP Client converts the structured tool request into JSON-RPC.

Example JSON-RPC Request:

```json
{
  "jsonrpc": "2.0",
  "method": "createIssue",
  "params": {
    "title": "Bug Report",
    "description": "Fix login error"
  },
  "id": 101
}
```

This is sent to the MCP Server.

Important:

The client does NOT directly call GitHub.

It sends a standardized JSON-RPC message to the server.

---

# ğŸ–¥ Step 4 â€“ Server Receives JSON-RPC Message

The MCP Server:

* Receives JSON-RPC request
* Parses JSON
* Identifies method
* Extracts parameters

The server understands:

> "I need to execute createIssue with these parameters."

---

# ğŸ”Œ Step 5 â€“ Server Calls Tools / Database / API

The server now:

* Calls GitHub API
* Executes database queries (if needed)
* Calls Slack API
* Performs calculations or actions

This may involve:

* Internal databases
* External APIs
* Cloud services
* Enterprise systems

---

# ğŸ“¤ Step 6 â€“ Server Sends Response in JSON-RPC Format

After execution, the server returns a JSON-RPC response.

Example:

```json
{
  "jsonrpc": "2.0",
  "result": {
    "issue_id": 452,
    "status": "created"
  },
  "id": 101
}
```

If error occurs:

```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": 500,
    "message": "GitHub API failed"
  },
  "id": 101
}
```

---

# ğŸ” Step 7 â€“ Client Receives JSON-RPC Response

The MCP Client:

* Matches response using ID
* Parses JSON
* Handles errors if present
* Converts structured result into context for LLM

---

# ğŸ—£ Step 8 â€“ LLM Converts Structured Data into Natural Language

Now the LLM inside the client takes the structured JSON result and converts it into simple human-readable text.

Example Output:

> "Your GitHub issue #452 has been successfully created, and the Slack team has been notified."

This is what the user sees.

---

# ğŸ“Š Full Communication Flow Diagram

```
User (Natural Language)
        â†“
MCP Host
        â†“
MCP Client (LLM understands intent)
        â†“
Client converts to JSON-RPC
        â†“
MCP Server receives JSON-RPC
        â†“
Server calls Tools / DB / APIs
        â†“
Server returns JSON-RPC response
        â†“
Client parses response
        â†“
LLM converts to simple text
        â†“
User receives final answer
```

---

# ğŸ§  Why This Design Is Powerful

* Clean separation of responsibilities
* Structured communication
* Standardized protocol
* Reliable request-response mapping
* Error handling support
* Language-independent
* Scalable architecture

---

# ğŸ“Œ Summary Table

| Stage           | Format                 |
| --------------- | ---------------------- |
| User input      | Natural language       |
| Client â†’ Server | JSON-RPC request       |
| Server â†’ Tools  | API calls / DB queries |
| Server â†’ Client | JSON-RPC response      |
| Client â†’ User   | Natural language       |

---

# ğŸ Final Understanding

JSON-RPC is the structured communication layer used in MCP.

It allows clients and servers to exchange standardized request-response messages.

The LLM understands human language.

The client converts it into JSON-RPC.

The server executes tools and returns JSON-RPC.

The client parses it.

The LLM converts structured results back into simple text for the user.

This ensures clean, scalable, and reliable AI-to-tool communication.

---

**End of Document**
